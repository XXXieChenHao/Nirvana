<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script type="text/javascript">
  // function a() {
  //   function b() {
  //     var b = 2;
  //   }
  //   var a = 1;
  //   b();
  // }
  // var c = 3;
  // a();
  </script>
  <!-- 当 a 函数被定义时，系统生成 [[scope]] 属性，[[scope]] 保存该函数的作用域链，该作用域链的第0位存储当前环境下的全局执行期上下文 GO， GP里存储全局下的所有对象，其中包含函数a和全局变量c -->
  <!-- 每一个函数作用域链上一定都有 GO -->
  <!-- 每一个函数定义的时候就已经包含了全局上下文 GO，每一个函数的作用域链都包含 GO  -->

  <!-- 当 a 函数被执行的（预编译的前一刻）作用域链的顶端（第 0 位）存储 a 函数生成的函数执行期上下文 AO， 同时第 1 位存储 GO。 查找变量时到 a 函数存储的作用域链中从顶端开始一次向下查找 -->

  <!-- AO 排在 GO 的上方  -->

  <!-- 当 b 函数被定义时，是在 a 函数环境下，所以 b 函数这时的作用域链就是 a 函数被执行的作用域链 -->
  <!-- 外层函数在被执行的时候，内层函数在被定义
       在没有被执行（被定义时）永远都是上级的环境
       只有被执行的时候才会有新的东西出来 
  -->

  <!-- 当 b 函数被执行时（预编译的前一刻）生成函数 b 的 [[scope]], 存储函数 b 的作用域链，顶端第 0 位存储 b 函数的 AO， a 函数的 AO 和全局的 GO 依次后移一位，同样 -->
  <!-- 当 b 函数被执行结束后， b 函数的 AO 被销毁， 回归被定义的时的状态 -->

  <!-- 当 a 函数被执行结束时，a 函数的 AO 被销毁的同时， b 函数的 [[scope]] 也将不存在。 a 函数回到被定义时的状态 -->


  <!-- 全局执行的前一刻 GO -> 函数声明已经定义了（函数表达式没有被定义） -->
  <!-- 函数被的定义时 已经存在作用域 [[scope]] 已经存在作用域链 scope chain 已经存在 GO（上级环境）
  函数被执行的时候才会生成 AO -->
</body>

</html>